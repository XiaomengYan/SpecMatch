{
    "collab_server" : "",
    "contents" : "#include <RcppArmadillo.h>\n#include <cmath>\n#include <vector>\nusing namespace Rcpp;\nusing namespace arma;\n\n\n//[[Rcpp::export]]\narma::mat StarletWT(arma::vec X){\n// Starlet Second Generation WT\n  int N = X.size(); // Get the length of the input signal X\n  int J = floor(log2(N)); // Get the total scale of the wavelet transform\n  arma::mat C(J+1,N,fill::zeros),W(J,N,fill::zeros);\n  arma::mat V(J+1,N,fill::zeros);\n  for(int i = 0 ;i <N;i++){\n    C.at(0,i) = X.at(i);\n  }\n  arma::vec h_1(5,fill::ones),h_1D(5,fill::ones);\n  h_1[1] = 4;\n  h_1[2] = 6;\n  h_1[3] = 4;\n  h_1D = 1.0/16 * h_1;\n  double e = 0.0;\n  for(int j = 0;j< J;j++){\n    // Level\n    for(int l = 0; l< N;l++){\n      //position\n      double sum = 0.0;\n      for(int k = -2;k<3;k++){\n        int lpk = l+pow(2,j)*k;\n        while(lpk<0||lpk>(N-1)){\n          if(lpk<0){\n            lpk = -1*lpk;\n          }\n          if(lpk > (N-1)){\n            lpk = 2*(N-1)-lpk;\n          }\n        }\n        e = C.at(j,lpk)*h_1D[k+2];\n        sum = sum + e;\n      }\n      C.at(j+1,l) = sum;\n    }//position\n// Second Transform towards c_j+1\n    for(int l = 0; l< N;l++){\n      double sum = 0.0;\n      for(int k = -2;k<3;k++){\n        int lpk = l+pow(2,j)*k;\n        while(lpk<0||lpk>(N-1)){\n          if(lpk<0){\n            lpk = -1*lpk;\n          }\n          if(lpk>(N-1)){\n            lpk = 2*(N-1)-lpk;\n          }\n        }\n        e = C.at(j+1,lpk)*h_1D[k+2];\n        sum = sum + e;\n      }\n      V.at(j+1,l) = sum;\n    }//position\n    W.row(j) = C.row(j)-V.row(j+1);\n  }//level\n  for(int j = 0; j< J+1;j++){\n    if(j<J){\n      C.row(j) = W.row(j);\n    }else{\n      C.row(j) = C.row(j);\n    }\n  }\n  return(C);\n}\n\n//[[Rcpp::export]]\narma::mat StarletRC(arma::mat X){\n  // Reconstruction Algorithm for the Starlet Second Generation WT\n  int N = X.n_cols;\n  int J = X.n_rows;\n  arma::vec h_1(5,fill::ones),h_1D(5,fill::ones);\n  h_1[1] = 4;\n  h_1[2] = 6;\n  h_1[3] = 4;\n  h_1D = 1.0/16 * h_1;\n  arma::mat V(1,N,fill::zeros);\n  arma::mat C(J,N);//J_1 the Number of J + 1\n  C.row(J-1) = X.row(J-1);\n  double e = 0.0;\n  for(int j = J-1;j > 0 ;j--){\n    for(int l = 0;l< N;l++){\n      double sum = 0.0;\n      for(int k = -2;k<3;k++){\n        double lpk = l+pow(2,j-1)*k;\n        while(lpk<0||lpk>(N-1)){\n          if(lpk<0){\n            lpk = -1*lpk;\n          }\n          if(lpk>(N-1)){\n            lpk = 2*(N-1)-lpk;\n          }\n        }//while\n        e = C.at(j,lpk)*h_1D(k+2);\n        sum = sum + e;\n    }\n      V.at(0,l) = sum;\n  }\n    C.row(j-1) = V + X.row(j-1);\n}\n  return(C.row(0));\n}\n\n//[[Rcpp::export]]\nRcpp::List PMT(arma::vec X){\n  //pyramidal median transform\n  int N = X.size();\n  int J = floor(log2(N));\n  arma::mat C(J+1,N,fill::zeros);\n  arma::mat C_t(J,N,fill::zeros);\n  arma::mat C_med(J,N,fill::zeros);\n  arma::mat W(J,N,fill::zeros);\n  arma::vec window(7,fill::zeros);\n  arma::vec V(J+1,fill::zeros);\n  V.at(0) = N;//Vector to record the number\n               //of element in each level. The 0 element is the original signal lengt\n  for(int i = 0 ;i <N;i++){\n    C.at(0,i) = X.at(i);\n  }\n  for(int j=0;j<J;j++){\n    for(int l=0;l<N;l++){\n      for(int i = l-3;i<l+4;i++){\n        int h = i;\n        while(h<0||h>N-1){\n          if(h<0){h = -1* h;}\n          if(h>(N-1)){h = 2*(N-1)-h;}\n        }\n        window.at(i+3-l) = C.at(j,h);\n      }//i\n      C_med(j,l) = median(window);\n    }//l\n    // Extract the odd term of C_med(j+1,:) to get C(j+1,:)\n    V.at(j+1) = floor(N/2.0)+N%2;\n    for(int k = 0;k< V.at(j+1);k++){\n      C(j+1,k) = C_med.at(j,2*k);\n    }//k\n    //Interpolation of C_{j+1} to the size of C_{j}\n    int V_j = V.at(j+1);\n    int t = 2*V_j - N%2;\n    // If N is odd\n    if(N%2==1){\n      for(int m = 0;m<t;m++){\n        for(int k = 0;k<V_j;k++){\n          if(m==2*k){C_t.at(j+1,m) = C(j+1,k);}\n          if(m==(2*k+1)&&m<N){C_t.at(j+1,m) = (C.at(j+1,k)+C.at(j+1,k+1))/2.0;}\n        }//k\n      }//m\n    }//if\n    // If N is even\n    if(N%2==0){\n      for(int m = 0;m<(t-1);m++){\n        for(int k = 0;k<V_j;k++){\n          if(m==2*k){C_t.at(j,m) = C(j+1,k);}\n          if(m==(2*k+1)&&m<N){C_t.at(j,m) = (C.at(j+1,k)+C.at(j+1,k+1))/2.0;}\n        }//k\n      }//m\n      //The last term is equal to the term before the last term\n      C_t.at(j,t-1) = C_t.at(j,t-2);\n    }//if\n    N = V_j;\n    W.row(j) = C.row(j) - C_t.row(j);\n  }//j\n  for(int j = 0;j<J;j++){\n    C.row(j) = W.row(j);\n  }\n  return Rcpp::List::create(Rcpp::Named(\"C\") = C,Rcpp::Named(\"NumberIndex\") = V);\n}\n\n//[[Rcpp::export]]\narma::mat PMTRC(arma::mat C,arma::vec V){\n  //reconstruction of prymdial median transform\n  //We use linear intorpolation\n  //Input: coefficient matrix X = {w1,...wJ,cJ}; V = Number of element in each scale\n  int N = C.n_cols;\n  int J = C.n_rows; //(log2(N)+1)\n  arma::mat C_t(J,N,fill::zeros);\n  for(int j = J-1;j>0;j--){\n    int V_j_1 = V.at(j-1);\n    N = V.at(j)*2 - V_j_1%2;\n    //Interpolation of C_{j+1} to the size of C_{j}\n    // If N is odd\n    if(V_j_1%2==1){\n      for(int m = 0;m<N;m++){\n        for(int k = 0;k<V.at(j);k++){\n          if(m==2*k){C_t.at(j,m) = C(j,k);}\n          if(m==(2*k+1)&&m<N){C_t.at(j,m) = (C.at(j,k)+C.at(j,k+1))/2.0;}\n        }//k\n      }//m\n    }//if\n    // If N is even\n    if(V_j_1%2==0){\n      for(int m = 0;m<N;m++){\n        for(int k = 0;k<V.at(j);k++){\n          if(m==2*k){C_t.at(j,m) = C(j,k);}\n          if(m==(2*k+1)&&m<N){C_t.at(j,m) = (C.at(j,k)+C.at(j,k+1))/2.0;}\n        }//k\n      }//m\n      //The last term is equal to the term before the last term\n      C_t.at(j,N-1) = C_t.at(j,N-2);\n    }//if\n    C.row(j-1) = C.row(j-1) + C_t.row(j);\n  }//j\n  return C.row(0);\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n///// The Multiresolution support ///////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////\n//\n// //[[Rcpp::export]]\n// arma::mat MultiResSuppPMT(arma::vec X,int SimNo){\n//   //Get the multiresolution support of wavelet coefficient C based on simulation\n//   //Input: The origianl signal\n//   //Output: Simulation size\n//   Rcpp::List C(SimNo);\n//   int N = X.size();\n//   int J = floor(log2(N));\n//   arma::mat C_n;\n//   arma::mat M(J+1,N,fill::zeros);\n//   arma::vec RandDraw(N,fill::zeros);\n//   Rcpp::List PMT_res = PMT(X);\n//   arma::mat C_signal = PMT_res.at(0);\n//   arma::vec V_signal = PMT_res.at(1);\n//   for(int n=0;n<SimNo;n++){\n//     RandDraw = randn(N);\n//     arma::mat C_n = PMT(RandDraw).at(0);\n//     C.at(n) = C_n;\n//     //Rcpp::Rcout<<C_n<<std::endl;\n//   }\n//   for(int j =0;j<J+1;j++){\n//     //position\n//     int V_j = V_signal.at(j);\n//     //Rcpp::Rcout<< V_j <<std::endl;\n//     for(int n =0;n< V_j;n++){\n//       //scale\n//       arma::vec tmp(SimNo,fill::zeros);\n//       for(int i = 0;i<SimNo;i++){\n//         arma::mat C_i = C.at(i);\n//         tmp.at(i) = C_i.at(j,n);\n//       }//i\n//       //double absCjn = fabs(C_signal.at(j,n));\n//       //if( absCjn > 3*stddev(tmp)){M.at(j,n) = 1;}\n//       M.at(j,n) = stddev(tmp);\n//       //Rcpp::Rcout<<tmp<<std::endl;\n//     }//j\n//   }//n\n//   return M;\n// }\n\n\n\n//[[Rcpp::export]]\ndouble MAD(arma::rowvec X){\n  double Med = median(X);\n  arma::vec MADres(X.size(),fill::zeros);\n  for(int j = 0;j<X.size();j++){\n    MADres.at(j) = fabs(X.at(j) - Med);\n  }\n  double res = median(MADres);\n  return res;\n}\n\n\n//[[Rcpp::export]]\narma::vec MultiResSuppStarlet(arma::vec X,int NoSimu){\n    //Get the multiresolution support of wavelet coefficient C based on simulation\n    //Input: The origianl signal\n    //Output: noise standard deviation of each level\n  int N = X.size();\n  int J = floor(log2(N));\n  arma::mat sigmaEMat(NoSimu,J,fill::zeros);// The noise standard deviation generated by simulation and transform\n  arma::mat ResSignal = StarletWT(X);\n  arma::vec sigmaJ(J,fill::zeros);// The noise standard deviation of coefficients at each level j\n  double sigmaS;//The noise standard deviation of original signal MED(|w_1|)/0.6745\n  for(int n = 0;n<NoSimu;n++){\n    arma::vec RandDraw = randn(N);\n    arma::mat ResStarlet = StarletWT(RandDraw);\n    for(int j=0; j< J; j++){\n      sigmaEMat.at(n,j) = stddev(ResStarlet.row(j));\n    }//j\n  }//n\n  arma::rowvec w1 = ResSignal.row(0);\n  double sigmaE1 = mean(sigmaEMat.col(0));\n  sigmaS = MAD(w1)/0.6745;\n  for(int j = 0;j<J;j++){\n    sigmaJ.at(j) = sigmaS/sigmaE1*mean(sigmaEMat.col(j));\n  }\n  return sigmaJ;\n}\n\n\n\n\n\n// //[[Rcpp::export]]\n// arma::mat MultiResSuppStarlet(arma::vec X,int SimNo){\n//   //Get the multiresolution support of wavelet coefficient C based on simulation\n//   //Input: The origianl signal\n//   //Output: Simulation size\n//   Rcpp::List C(SimNo);\n//   int N = X.size();\n//   int J = floor(log2(N));\n//   arma::mat C_n;\n//   arma::mat M(J+1,N,fill::zeros);\n//   arma::vec RandDraw(N,fill::zeros);\n//   arma::mat C_signal = StarletWT(X);\n//   for(int n=0;n<SimNo;n++){\n//     RandDraw = randn(N);\n//     arma::mat C_n= StarletWT(RandDraw);\n//     C.at(n) = C_n;\n//   }\n//   for(int n =0;n< N;n++){\n//     //position\n//     for(int j =0;j<J+1;j++){\n//       //scale\n//       arma::vec tmp(SimNo,fill::zeros);\n//       for(int i = 0;i<SimNo;i++){\n//         arma::mat C_i = C.at(i);\n//         tmp.at(i) = C_i.at(j,n);\n//       }//i\n//       //double absCjn = fabs(C_signal.at(j,n));\n//       M.at(j,n) = stddev(tmp);\n//      // if( absCjn > 3*stddev(tmp)){M.at(j,n) = 1;}\n//     }//j\n//   }//n\n//   return M;\n// }\n\n\n///////////////////////////////////////////////////////////////////////\n///////// Threshold////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////\n\n//[[Rcpp::export]]\narma::mat HardThreshold(arma::mat C, arma::rowvec M){\n  int N = C.n_cols;\n  int J = C.n_rows;\n  for(int n = 0;n<N;n++){\n    for(int j = 0;j<J;j++){\n      if(fabs(C.at(j,n)) < 3*M.at(j)){C.at(j,n) = 0;}\n    }\n  }\n  return C;\n}\n\n//[[Rcpp::export]]\nint sign(double x){\n  int i=0;\n  if(x>0){i = 1;}\n  return i;\n}\n\n//[[Rcpp::export]]\narma::mat SoftThreshold(arma::mat C, arma::vec M){\n  int N = C.n_cols;\n  int J = C.n_rows;\n  for(int n = 0;n<N;n++){\n    for(int j = 0;j<J;j++){\n      if(fabs(C.at(j,n)) < 3*M.at(j)){C.at(j,n) = 0;}\n      else{C.at(j,n) = sign(C.at(j,n))*fabs(C.at(j,n))-M.at(j);}\n    }\n  }\n  return C;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "created" : 1541096698670.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3712039594",
    "id" : "EEE91954",
    "lastKnownWriteTime" : 1541528170,
    "last_content_update" : 1541528170006,
    "path" : "~/Dropbox/project/Wang/SpecMatch/src/WTtools.cpp",
    "project_path" : "src/WTtools.cpp",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}